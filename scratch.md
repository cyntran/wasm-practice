// lib.rs is the root of the rust crate compiled to webassembly 

// wasm-pack is used to ensure we have Rust 1.30+, 
// wasm32-unknown-unknown is installed via rustup,
// compile Rust sources to Web Assembly .wasm binary via cargo,
// use wasm-bindgen to generate the javascript API for our rust-generated webassembly 
// COMMAND: wasm-pack build

// pkg directory: 
// wasm-game-of-life-bg.wasm -> WebAssembly binary generated by Rust compiler
//      exports all the rust functions/data
// wasm-game-of-life.js -> generated by wasm-bindgen and contains the JS glue
//      for importing DOM and JS functions into Rust and exposing a nice API 
//      to the WebAssembly functions to JS 
// wasm-game-of-life-.d.ts -> Typscript types for the JS glue. 
// package.json -> metadata about the JS and WebAssembly package. Used by 
//      npm & js bundlers to determine dependencies across packages. 

// create-wasm-app is a template for kick starting a project using 
//      npm packages that contain Rust-generated WebAssembly and bundles them
//      with webpack. 
// COMMAND: npm init wasm-app www 
// www directory: 
//      package.json -> pre-configured with webpack and webpack-dev-server dependencies.
//      webpack.config.js -> webpack configuration and local dev server. 
//      index.html -> root HTML file that loads bootstrap
//      index.js -> entry point for our javascript code. it contains hello-wasm-pack,
//        which contains the default wasm-pack-template compiled webassmebly/js glue. 

// install dependencies for local dev server by running npm install in the www/ subdirectory. 
// Parceljs or Rollup works for importing WebAssembly as ECMAScript modules too, 
//      webpack is used for convenience. 

// Use our local wasm-game-of-life package in www instead of the hello-wasm-pack package:
//     www/package.json -> edit dependencies to include "wasm-game-of-life: "file:../pkg"
//     modify index.js -> import * as wasm from "wasm-game-of-life";
//     call npm install
//     cd www && npm run start
//     wasm-pack build -> call this within wasm-game-of-life directory when making updates
//     to the webpage. 


RULES OF CONWAY'S GAME OF LIFE: 

The universe of the Game of Life is an infinite two-dimensional orthogonal grid of square cells, each of which is in one of two possible states, alive or dead, or "populated" or "unpopulated". Every cell interacts with its eight neighbours, which are the cells that are horizontally, vertically, or diagonally adjacent. At each step in time, the following transitions occur:

Any live cell with fewer than two live neighbours dies, as if caused by underpopulation.

Any live cell with two or three live neighbours lives on to the next generation.

Any live cell with more than three live neighbours dies, as if by overpopulation.

Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.

The initial pattern constitutes the seed of the system. The first generation is created by applying the above rules simultaneously to every cell in the seedâ€”births and deaths occur simultaneously, and the discrete moment at which this happens is sometimes called a tick (in other words, each generation is a pure function of the preceding one). The rules continue to be applied repeatedly to create further generations.

-----------------------------------------------------------------------------------

*Interfacing Rust and Javascript* 
- JS garbage collected heap where objects & arrays and dom nodes are allocated
is distinct from webassembly's linear memory space where Rust values live. 
- webassembly can't have direct access to garbage-collected heap. 
- JS can read/write to the webassembly linear memory space but only 
as arraybuffer (fixed-lengthed raw binary data buffer) of scalar values (u8, i32, f64, etc) 
- webassembly can also take and return scalar values. 
- therefore, these are the building blocks for communication between the two. 

wasm-bindgen defines the understanding how to work with these structures. 
it involves boxing Rust structures and wrapping the pointer in a JS class
for usability, or indexing into a table of JS objects from Rust. it's a tool for implementing the interface design you choose. 

to avoid overhead, we want to: 
1. minmize copying into & out of webassembly linear memory
2. minimize serializing and deserializing: pass in opaque handles to a data structure
instead of serializing it on one side, copying it to some known location in the web assembly linear memory, and deserializing it on the other side. wasm-bindgen helps us work with opaque handles to JS objects or boxed Rust structures.

rule of thumb:
- a good JS - WebAssembly interface design is often times one where large, long-lived data structures are implemented as Rust types living in WebAssembly linear mem and exposed to JS as opaque handles. These exported WebAssembly functions which have these opaque handles and transform their data, perform heavy computations, query data, and ultimately return a small, copy-able result are called by JS. 
- By returning a small, copy-able result, we avoid copying/serializing things back & forth between the JS garbage-collected heap and the WebAssembly linear memory. 

--------------------

rust string -> copied from web assembly linear memory -> into a js string in js garbage-collected heap -> display using HTML textContent 

We can access WebAssembly's linear memory via 'memory' defined in the raw wasm module,
'wasm_game_of_life.bg'
- import {memory} from 'wasm-game-of-life/wasm_game_of_life.bg";